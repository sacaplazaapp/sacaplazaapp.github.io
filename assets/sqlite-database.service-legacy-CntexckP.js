!function(){function e(e,t,s){return(t=function(e){var t=function(e,t){if("object"!=typeof e||!e)return e;var s=e[Symbol.toPrimitive];if(void 0!==s){var r=s.call(e,t||"default");if("object"!=typeof r)return r;throw new TypeError("@@toPrimitive must return a primitive value.")}return("string"===t?String:Number)(e)}(e,"string");return"symbol"==typeof t?t:t+""}(t))in e?Object.defineProperty(e,t,{value:s,enumerable:!0,configurable:!0,writable:!0}):e[t]=s,e}System.register(["./index-legacy-CSXa1uLC.js"],function(t,s){"use strict";var r,a,n;return{setters:[e=>{r=e.r,a=e._,n=e.C}],execute:function(){class i{constructor(e){this.sqlite=e,this._connectionDict=new Map}async initWebStore(){try{return await this.sqlite.initWebStore(),Promise.resolve()}catch(e){return Promise.reject(e)}}async saveToStore(e){try{return await this.sqlite.saveToStore({database:e}),Promise.resolve()}catch(t){return Promise.reject(t)}}async saveToLocalDisk(e){try{return await this.sqlite.saveToLocalDisk({database:e}),Promise.resolve()}catch(t){return Promise.reject(t)}}async getFromLocalDiskToStore(e){const t=null==e||e;try{return await this.sqlite.getFromLocalDiskToStore({overwrite:t}),Promise.resolve()}catch(s){return Promise.reject(s)}}async echo(e){try{const t=await this.sqlite.echo({value:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async isSecretStored(){try{const e=await this.sqlite.isSecretStored();return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async setEncryptionSecret(e){try{return await this.sqlite.setEncryptionSecret({passphrase:e}),Promise.resolve()}catch(t){return Promise.reject(t)}}async changeEncryptionSecret(e,t){try{return await this.sqlite.changeEncryptionSecret({passphrase:e,oldpassphrase:t}),Promise.resolve()}catch(s){return Promise.reject(s)}}async clearEncryptionSecret(){try{return await this.sqlite.clearEncryptionSecret(),Promise.resolve()}catch(e){return Promise.reject(e)}}async checkEncryptionSecret(e){try{const t=await this.sqlite.checkEncryptionSecret({passphrase:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async addUpgradeStatement(e,t){try{return e.endsWith(".db")&&(e=e.slice(0,-3)),await this.sqlite.addUpgradeStatement({database:e,upgrade:t}),Promise.resolve()}catch(s){return Promise.reject(s)}}async createConnection(e,t,s,r,a){try{e.endsWith(".db")&&(e=e.slice(0,-3)),await this.sqlite.createConnection({database:e,encrypted:t,mode:s,version:r,readonly:a});const n=new o(e,a,this.sqlite),i=a?`RO_${e}`:`RW_${e}`;return this._connectionDict.set(i,n),Promise.resolve(n)}catch(n){return Promise.reject(n)}}async closeConnection(e,t){try{e.endsWith(".db")&&(e=e.slice(0,-3)),await this.sqlite.closeConnection({database:e,readonly:t});const s=t?`RO_${e}`:`RW_${e}`;return this._connectionDict.delete(s),Promise.resolve()}catch(s){return Promise.reject(s)}}async isConnection(e,t){const s={};e.endsWith(".db")&&(e=e.slice(0,-3));const r=t?`RO_${e}`:`RW_${e}`;return s.result=this._connectionDict.has(r),Promise.resolve(s)}async retrieveConnection(e,t){e.endsWith(".db")&&(e=e.slice(0,-3));const s=t?`RO_${e}`:`RW_${e}`;if(this._connectionDict.has(s)){const t=this._connectionDict.get(s);return void 0!==t?Promise.resolve(t):Promise.reject(`Connection ${e} is undefined`)}return Promise.reject(`Connection ${e} does not exist`)}async getNCDatabasePath(e,t){try{const s=await this.sqlite.getNCDatabasePath({path:e,database:t});return Promise.resolve(s)}catch(s){return Promise.reject(s)}}async createNCConnection(e,t){try{await this.sqlite.createNCConnection({databasePath:e,version:t});const s=new o(e,!0,this.sqlite),r=`RO_${e})`;return this._connectionDict.set(r,s),Promise.resolve(s)}catch(s){return Promise.reject(s)}}async closeNCConnection(e){try{await this.sqlite.closeNCConnection({databasePath:e});const t=`RO_${e})`;return this._connectionDict.delete(t),Promise.resolve()}catch(t){return Promise.reject(t)}}async isNCConnection(e){const t={},s=`RO_${e})`;return t.result=this._connectionDict.has(s),Promise.resolve(t)}async retrieveNCConnection(e){if(this._connectionDict.has(e)){const t=`RO_${e})`,s=this._connectionDict.get(t);return void 0!==s?Promise.resolve(s):Promise.reject(`Connection ${e} is undefined`)}return Promise.reject(`Connection ${e} does not exist`)}async isNCDatabase(e){try{const t=await this.sqlite.isNCDatabase({databasePath:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async retrieveAllConnections(){return this._connectionDict}async closeAllConnections(){const e=new Map;try{for(const t of this._connectionDict.keys()){const s=t.substring(3),r="RO_"===t.substring(0,3);await this.sqlite.closeConnection({database:s,readonly:r}),e.set(t,null)}for(const t of e.keys())this._connectionDict.delete(t);return Promise.resolve()}catch(t){return Promise.reject(t)}}async checkConnectionsConsistency(){try{const e=[...this._connectionDict.keys()],t=[],s=[];for(const a of e)t.push(a.substring(0,2)),s.push(a.substring(3));const r=await this.sqlite.checkConnectionsConsistency({dbNames:s,openModes:t});return r.result||(this._connectionDict=new Map),Promise.resolve(r)}catch(e){return this._connectionDict=new Map,Promise.reject(e)}}async importFromJson(e){try{const t=await this.sqlite.importFromJson({jsonstring:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async isJsonValid(e){try{const t=await this.sqlite.isJsonValid({jsonstring:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async copyFromAssets(e){const t=null==e||e;try{return await this.sqlite.copyFromAssets({overwrite:t}),Promise.resolve()}catch(s){return Promise.reject(s)}}async getFromHTTPRequest(e,t){const s=null==t||t;try{return await this.sqlite.getFromHTTPRequest({url:e,overwrite:s}),Promise.resolve()}catch(r){return Promise.reject(r)}}async isDatabaseEncrypted(e){e.endsWith(".db")&&(e=e.slice(0,-3));try{const t=await this.sqlite.isDatabaseEncrypted({database:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async isInConfigEncryption(){try{const e=await this.sqlite.isInConfigEncryption();return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async isInConfigBiometricAuth(){try{const e=await this.sqlite.isInConfigBiometricAuth();return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async isDatabase(e){e.endsWith(".db")&&(e=e.slice(0,-3));try{const t=await this.sqlite.isDatabase({database:e});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async getDatabaseList(){try{const e=(await this.sqlite.getDatabaseList()).values;e.sort();const t={values:e};return Promise.resolve(t)}catch(e){return Promise.reject(e)}}async getMigratableDbList(e){const t=e||"default";try{const e=await this.sqlite.getMigratableDbList({folderPath:t});return Promise.resolve(e)}catch(s){return Promise.reject(s)}}async addSQLiteSuffix(e,t){const s=e||"default",r=t||[];try{const e=await this.sqlite.addSQLiteSuffix({folderPath:s,dbNameList:r});return Promise.resolve(e)}catch(a){return Promise.reject(a)}}async deleteOldDatabases(e,t){const s=e||"default",r=t||[];try{const e=await this.sqlite.deleteOldDatabases({folderPath:s,dbNameList:r});return Promise.resolve(e)}catch(a){return Promise.reject(a)}}async moveDatabasesAndAddSuffix(e,t){const s=e||"default",r=t||[];return this.sqlite.moveDatabasesAndAddSuffix({folderPath:s,dbNameList:r})}}class o{constructor(e,t,s){this.dbName=e,this.readonly=t,this.sqlite=s}getConnectionDBName(){return this.dbName}getConnectionReadOnly(){return this.readonly}async open(){try{return await this.sqlite.open({database:this.dbName,readonly:this.readonly}),Promise.resolve()}catch(e){return Promise.reject(e)}}async close(){try{return await this.sqlite.close({database:this.dbName,readonly:this.readonly}),Promise.resolve()}catch(e){return Promise.reject(e)}}async beginTransaction(){try{const e=await this.sqlite.beginTransaction({database:this.dbName});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async commitTransaction(){try{const e=await this.sqlite.commitTransaction({database:this.dbName});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async rollbackTransaction(){try{const e=await this.sqlite.rollbackTransaction({database:this.dbName});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async isTransactionActive(){try{const e=await this.sqlite.isTransactionActive({database:this.dbName});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async loadExtension(e){try{return await this.sqlite.loadExtension({database:this.dbName,path:e,readonly:this.readonly}),Promise.resolve()}catch(t){return Promise.reject(t)}}async enableLoadExtension(e){try{return await this.sqlite.enableLoadExtension({database:this.dbName,toggle:e,readonly:this.readonly}),Promise.resolve()}catch(t){return Promise.reject(t)}}async getUrl(){try{const e=await this.sqlite.getUrl({database:this.dbName,readonly:this.readonly});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async getVersion(){try{const e=await this.sqlite.getVersion({database:this.dbName,readonly:this.readonly});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async getTableList(){try{const e=await this.sqlite.getTableList({database:this.dbName,readonly:this.readonly});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async execute(e,t=!0,s=!0){try{if(this.readonly)return Promise.reject("not allowed in read-only mode");{const r=await this.sqlite.execute({database:this.dbName,statements:e,transaction:t,readonly:!1,isSQL92:s});return Promise.resolve(r)}}catch(r){return Promise.reject(r)}}async query(e,t,s=!0){let r;try{return r=t&&t.length>0?await this.sqlite.query({database:this.dbName,statement:e,values:t,readonly:this.readonly,isSQL92:!0}):await this.sqlite.query({database:this.dbName,statement:e,values:[],readonly:this.readonly,isSQL92:s}),r=await this.reorderRows(r),Promise.resolve(r)}catch(a){return Promise.reject(a)}}async run(e,t,s=!0,r="no",a=!0){let n;try{return this.readonly?Promise.reject("not allowed in read-only mode"):(n=t&&t.length>0?await this.sqlite.run({database:this.dbName,statement:e,values:t,transaction:s,readonly:!1,returnMode:r,isSQL92:!0}):await this.sqlite.run({database:this.dbName,statement:e,values:[],transaction:s,readonly:!1,returnMode:r,isSQL92:a}),n.changes=await this.reorderRows(n.changes),Promise.resolve(n))}catch(i){return Promise.reject(i)}}async executeSet(e,t=!0,s="no",r=!0){let a;try{return this.readonly?Promise.reject("not allowed in read-only mode"):(a=await this.sqlite.executeSet({database:this.dbName,set:e,transaction:t,readonly:!1,returnMode:s,isSQL92:r}),a.changes=await this.reorderRows(a.changes),Promise.resolve(a))}catch(n){return Promise.reject(n)}}async isExists(){try{const e=await this.sqlite.isDBExists({database:this.dbName,readonly:this.readonly});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async isTable(e){try{const t=await this.sqlite.isTableExists({database:this.dbName,table:e,readonly:this.readonly});return Promise.resolve(t)}catch(t){return Promise.reject(t)}}async isDBOpen(){try{const e=await this.sqlite.isDBOpen({database:this.dbName,readonly:this.readonly});return Promise.resolve(e)}catch(e){return Promise.reject(e)}}async delete(){try{return this.readonly?Promise.reject("not allowed in read-only mode"):(await this.sqlite.deleteDatabase({database:this.dbName,readonly:!1}),Promise.resolve())}catch(e){return Promise.reject(e)}}async createSyncTable(){try{if(this.readonly)return Promise.reject("not allowed in read-only mode");{const e=await this.sqlite.createSyncTable({database:this.dbName,readonly:!1});return Promise.resolve(e)}}catch(e){return Promise.reject(e)}}async setSyncDate(e){try{return this.readonly?Promise.reject("not allowed in read-only mode"):(await this.sqlite.setSyncDate({database:this.dbName,syncdate:e,readonly:!1}),Promise.resolve())}catch(t){return Promise.reject(t)}}async getSyncDate(){try{const e=await this.sqlite.getSyncDate({database:this.dbName,readonly:this.readonly});let t="";return e.syncDate>0&&(t=new Date(1e3*e.syncDate).toISOString()),Promise.resolve(t)}catch(e){return Promise.reject(e)}}async exportToJson(e,t=!1){try{const s=await this.sqlite.exportToJson({database:this.dbName,jsonexportmode:e,readonly:this.readonly,encrypted:t});return Promise.resolve(s)}catch(s){return Promise.reject(s)}}async deleteExportedRows(){try{return this.readonly?Promise.reject("not allowed in read-only mode"):(await this.sqlite.deleteExportedRows({database:this.dbName,readonly:!1}),Promise.resolve())}catch(e){return Promise.reject(e)}}async executeTransaction(e,t=!0){let s=0,r=!1;if(this.readonly)return Promise.reject("not allowed in read-only mode");if(await this.sqlite.beginTransaction({database:this.dbName}),r=await this.sqlite.isTransactionActive({database:this.dbName}),!r)return Promise.reject("After Begin Transaction, no transaction active");try{for(const a of e){if("object"!=typeof a||!("statement"in a))throw new Error("Error a task.statement must be provided");if("values"in a&&a.values&&a.values.length>0){const e=a.statement.toUpperCase().includes("RETURNING")?"all":"no",r=await this.sqlite.run({database:this.dbName,statement:a.statement,values:a.values,transaction:!1,readonly:!1,returnMode:e,isSQL92:t});if(r.changes.changes<0)throw new Error("Error in transaction method run ");s+=r.changes.changes}else{const e=await this.sqlite.execute({database:this.dbName,statements:a.statement,transaction:!1,readonly:!1});if(e.changes.changes<0)throw new Error("Error in transaction method execute ");s+=e.changes.changes}}s+=(await this.sqlite.commitTransaction({database:this.dbName})).changes.changes;const r={changes:{changes:s}};return Promise.resolve(r)}catch(a){const e=a.message?a.message:a;return await this.sqlite.rollbackTransaction({database:this.dbName}),Promise.reject(e)}}async reorderRows(e){const t=e;if(null!=e&&e.values&&"object"==typeof e.values[0]&&Object.keys(e.values[0]).includes("ios_columns")){const s=e.values[0].ios_columns,r=[];for(let t=1;t<e.values.length;t++){const a=e.values[t],n={};for(const e of s)n[e]=a[e];r.push(n)}t.values=r}return Promise.resolve(t)}}const c=r("CapacitorSQLite",{web:()=>a(()=>s.import("./web-legacy-Bxufeq9T.js"),void 0).then(e=>new e.CapacitorSQLiteWeb),electron:()=>window.CapacitorCustomPlatform.plugins.CapacitorSQLite});t("default",new class{constructor(){e(this,"sqlite",void 0),e(this,"db",null),e(this,"dbName","chess_flashcards.db"),e(this,"dbVersion",1),this.sqlite=new i(c)}async initializeDatabase(){try{console.log(`Initializing native SQLite database for platform: ${n.getPlatform()}`),console.log("Checking SQLite connection consistency...");const e=await this.sqlite.checkConnectionsConsistency();console.log("SQLite connection consistency:",e);const t=await this.sqlite.checkConnectionsConsistency(),s=(await this.sqlite.isConnection(this.dbName,!1)).result;t.result&&s?(console.log("Retrieving existing connection..."),this.db=await this.sqlite.retrieveConnection(this.dbName,!1)):(console.log("Creating new database connection..."),this.db=await this.sqlite.createConnection(this.dbName,!1,"no-encryption",this.dbVersion,!1)),console.log("Opening database..."),await this.db.open(),console.log("Creating tables..."),await this.createTables(),console.log("Native SQLite database initialized successfully")}catch(e){throw console.error("Error initializing native SQLite database:",e),e}}async createTables(){if(!this.db)throw new Error("Database not initialized");try{await this.db.execute("\n      CREATE TABLE IF NOT EXISTS flashcards (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        title TEXT NOT NULL,\n        question TEXT NOT NULL,\n        comment TEXT,\n        answer TEXT NOT NULL,\n        tags TEXT,\n        fen1 TEXT,\n        fen2 TEXT,\n        created DATETIME DEFAULT CURRENT_TIMESTAMP,\n        updated DATETIME DEFAULT CURRENT_TIMESTAMP\n      );\n    "),await this.db.execute("\n      CREATE TABLE IF NOT EXISTS user_progress (\n        id INTEGER PRIMARY KEY AUTOINCREMENT,\n        flashcard_id INTEGER,\n        correct_answers INTEGER DEFAULT 0,\n        incorrect_answers INTEGER DEFAULT 0,\n        last_reviewed DATETIME DEFAULT CURRENT_TIMESTAMP,\n        FOREIGN KEY (flashcard_id) REFERENCES flashcards (id)\n      );\n    "),console.log("Tables created successfully")}catch(e){throw console.error("Error creating tables:",e),e}}getConnection(){return this.db}async closeDatabase(){if(this.db)try{await this.db.close(),await this.sqlite.closeConnection(this.dbName,!1),this.db=null,console.log("Native SQLite database closed successfully")}catch(e){throw console.error("Error closing native SQLite database:",e),e}}async addFlashcard(e,t,s,r,a,n,i){var o;if(!this.db)throw new Error("Database not initialized");return(null===(o=(await this.db.run("\n      INSERT INTO flashcards (title, question, comment, answer, tags, fen1, fen2)\n      VALUES (?, ?, ?, ?, ?, ?, ?)\n    ",[e,t,s,r,a||"",n||"",i||""])).changes)||void 0===o?void 0:o.lastId)||0}async getFlashcards(){if(!this.db)throw new Error("Database not initialized");let e="SELECT * FROM flashcards";e+=" ORDER BY created DESC";return(await this.db.query("SELECT * FROM flashcards ORDER BY created DESC",[])).values||[]}async updateFlashcard(e,t,s,r,a,n,i,o){if(!this.db)throw new Error("Database not initialized");await this.db.run("\n      UPDATE flashcards \n      SET title = ?, question = ?, comment = ?, answer = ?, tags = ?, fen1 = ?, fen2 = ?, updated = CURRENT_TIMESTAMP\n      WHERE id = ?\n    ",[t,s,r,a,n||"",i||"",o||"",e])}async deleteFlashcard(e){if(!this.db)throw new Error("Database not initialized");await this.db.run("DELETE FROM flashcards WHERE id = ?",[e]),await this.db.run("DELETE FROM user_progress WHERE flashcard_id = ?",[e])}async recordAnswer(e,t){if(!this.db)throw new Error("Database not initialized");const s=await this.db.query("SELECT id FROM user_progress WHERE flashcard_id = ?",[e]);if(s.values&&s.values.length>0){const s=`\n        UPDATE user_progress \n        SET ${t?"correct_answers = correct_answers + 1":"incorrect_answers = incorrect_answers + 1"},\n            last_reviewed = CURRENT_TIMESTAMP\n        WHERE flashcard_id = ?\n      `;await this.db.run(s,[e])}else{const s="\n        INSERT INTO user_progress (flashcard_id, correct_answers, incorrect_answers)\n        VALUES (?, ?, ?)\n      ";await this.db.run(s,[e,t?1:0,t?0:1])}}async getFlashcardProgress(e){var t;if(!this.db)throw new Error("Database not initialized");return(null===(t=(await this.db.query("SELECT * FROM user_progress WHERE flashcard_id = ?",[e])).values)||void 0===t?void 0:t[0])||null}})}}})}();
